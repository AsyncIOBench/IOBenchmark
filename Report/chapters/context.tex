‫
‫% -------------------------------------------------------
‫%  Abstract
‫% -------------------------------------------------------
% ‫\بدون‌تورفتگی \مهم{چکیده}: نگارش سمینار‌ علاوه بر بخش پژوهش و آماده‌سازی محتوا،
% ‫مستلزم رعایت نکات فنی و نگارشی دقیقی است 
% ‫که در تهیه‌ی یک پایان‌نامه‌ی موفق بسیار کلیدی و مؤثر است.
% ‫از آن جایی که بسیاری از نکات فنی مانند قالب کلی صفحات، شکل و اندازه‌ی قلم، صفحات عنوان و غیره در تهیه‌ی پایان‌نامه‌ها یکسان است، با استفاده از نرم‌افزار حروف‌چینی زی‌تک %\پاورقی{\XeTeX}  و افزونه‌ی زی‌پرشین %\پاورقی{XePersian}  یک قالب استاندارد برای تهیه‌ی پایان‌نامه‌ها ارائه گردیده است.
% ‫این قالب می‌تواند برای تهیه‌ی پایان‌نامه‌های کارشناسی و کارشناسی ارشد و نیز رساله‌ی دکتری مورد استفاده قرار گیرد.
% ‫این نوشتار به طور مختصر نحوه‌ی استفاده از این قالب را نشان می‌دهد.
% ‫
% ‫
% ‫%\پرش‌بلند
% ‫\بدون‌تورفتگی \مهم{واژه‌های کلیدی}: 
% ‫پایان‌نامه، حروف‌چینی، قالب، زی‌پرشین
% ‫%\صفحه‌جدید
‫
‫\usepackage{xepersian}
‫\settextfont{XB Niloofar} % You can replace this with any Persian font you use
‫\setlatintextfont{Times New Roman} % Set an appropriate English font
‫
‫
‫\section{مقدمه}
‫
‫
‫
‫‫\section{شبیه ساز NVMeVirt }
‫‫\subsection*{توضیحات}
‫
‫نحوه تعریف PCIeRoot
‫
‫مطالعه کد های مربوطه و تهیه مستند
‫
‫نحوه کارکرد شبیه ساز
‫
‫معماری آن و بخش های اساسی معماری
‫
‫سطح شبیه سازی (آیا شبیه سازی بر بستر دیسک فعلیست یا هم سطح آن یا لایه های پایینتر؟ آیا در سطح پیاده سازی شده امکان استفاده برنامه کاربر یا کرنل از آن وجود دارد؟...)
‫
‫مکان ذخیره سازی داده های این شبیه ساز
‫
‫نحوه کنترل سرعت دسترسی دیسک مجازی و شبیه سازی دیسک سرعت بالا روی لپ تاپ با دیسک سرعت پایین
‫
‫‫\subsection*{مراحل نصب و شبیه سازی}
‫مراحل نصب و ایجاد دیسک مجازی
‫
‫صحت کارکرد
‫
‫‫\subsection*{بررسی عملکرد مولفه ها توسط FIO}
‫
‫
‫تاثیر دو فراخوان سیستمی uringio و libaio در دیسک شبیە سازی شده NVMe
‫
‫مقایسه عملکرد از نظر TailLatency , Latency , IOPS
‫
‫
‫‫\subsection*{تحلیل نتایج}
‫
‫
‫‫\section{ابزار SPDK}
‫‫\subsection*{توضیحات}
‫
‫SPDK یک مجموعه متن‌باز از ابزارها و کتابخانه‌ها است که برای بهینه‌سازی برنامه‌های ذخیره‌سازی از طریق درایورهای کاربر-محور و مبتنی بر روش polling طراحی شده است. این کیت به‌طور ویژه برای بهینه‌سازی عملکرد ذخیره‌سازی NVMe استفاده می‌شود و با دور زدن پشته I/O مبتنی بر کرنل، که می‌تواند باعث تأخیر و کاهش کارایی شود، عملکرد را بهبود می‌بخشد. SPDK از DPDK برای پردازش سریع داده‌ها استفاده می‌کند و درایور NVMe را مستقیماً در فضای کاربری اجرا می‌کند، که منجر به حذف تغییرات هزینه‌بر بین حالت کاربر و کرنل می‌شود. این معماری به برنامه‌ها امکان می‌دهد تا عملیات دیسک را با تأخیر بسیار کم و توان عملیاتی بالا انجام دهند، و در نتیجه، SPDK گزینه‌ای ایده‌آل برای راهکارهای ذخیره‌سازی در مراکز داده، محیط‌های ابری و برنامه‌های سازمانی با نیاز به عملکرد بالا محسوب می‌شود.
‫
‫علاوه بر NVMe، SPDK کتابخانه‌های بهینه‌شده‌ای برای پروتکل‌های ذخیره‌سازی مانند   NVMe-oF، iSCSI و ذخیره‌سازی blob ارائه می‌دهد. همچنین یک چارچوب برای ساخت راهکارهای کارآمد ذخیره‌سازی نرم‌افزاری فراهم می‌کند که می‌تواند با پلتفرم‌هایی مانند Ceph و OpenStack ادغام شود. طراحی غیرهمزمان و بدون قفل SPDK تضمین می‌کند که چرخه‌های پردازنده به طور کارآمد مورد استفاده قرار می‌گیرند، که این امر باعث می‌شود برنامه‌ها بتوانند حداکثر پهنای باند ذخیره‌سازی را با کمترین هزینه پردازشی به دست آورند. این ویژگی، SPDK را به گزینه‌ای جذاب برای شرکت‌هایی تبدیل می‌کند که به دنبال افزایش عملکرد ذخیره‌سازی با حداقل سرمایه‌گذاری سخت‌افزاری هستند.
‫
‫در ادامه این ابزار را نصب کرده و برای اجرای بنچ مارک روی دیسک NVMe از آن بهره می بریم.
‫
‫
‫
‫
‫
‫
‫
‫‫\subsection*{مراحل نصب}
‫برای نصب این ابزار بر روی linux ابتدا تمامی فایل های لازم را از github این ابزار به صورت بازگشتی clone می کنیم تا کل درخت فایل بر روی سیستم ما ایجاد شود.

\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{figs/gitclone.png}
    \caption{clone کردن از روی github}
\end{figure}


‫سپس با اجرای فایل pkgdep.sh در فولدر scripts تمامی dependency های لازم برای استفاده از SPDK نصب می شود.
‫
‫
‫\begin{figure}[H]
‫    \centering
‫    \includegraphics[width=\textwidth]{figs/pkgdep.png}
‫    \caption{نصب dependency ها}
‫\end{figure}
‫
‫حال باید SPDK را build کنیم. باید توجه داشت که fio نیز باید به همراه SPDK نصب شود. بنابراین آن را در دستور configure به صورت  --with-fio لحاظ می کنیم. با اجرای configure و بعد از آن make نصب انجام می شود.
‫
‫
\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{figs/configure.png}
    \caption{make کردن SPDK}
\end{figure}

برای اطمینان از صحت نصب SPDK تست های این ابزار را اجرا می کنیم. مشاهده می شود که تست ها همگی قبول شده اند و در نتیجه ابزار به درستی نصب شده است.

\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{figs/test.png}
    \caption{اجرای تست ها}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{figs/pass.png}
    \caption{نتیجه تست ها}
\end{figure}

در ادامه باید اطمینان حاصل کنیم که SPDK دیسک شبیه سازی شده را می شناسد. با اجرای فایل world hello مشخص می شود که SPDK این دیسک را شناخته است.

\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{figs/hello.png}
    \caption{شناخت دیسک شبیه سازی}
\end{figure}

‫‫\subsection*{بررسی عملکرد مولفه ها}
در این بخش با استفاده از پلاگین fio که با SPDK نصب شده است , شش بنچ مارک ذکر شده را اجرا می کنیم. در فایل های با فرمت bench<NUM>.fio تمامی attribute های مورد نیاز از جمله iodepth و size و ... را تعیین کرده و اجرا می کنیم. خروجی پرینت شده در لاگ بعد از اجرای بنچ مارک ها در فایل های با فرمت result<NUM>.txt ذخیره شده اند.

\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{figs/bench.png}
    \caption{اجرای بنچ مارک ها}
\end{figure}

در عکس زیر محتوای یکی از فایل های bench و result به طور نمونه آمده است.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.75\textwidth]{figs/bfile.png}
    \caption{اجرای بنچ مارک اول}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{figs/rfile.png}
    \caption{نتیجه بنچ مارک اول}
\end{figure}


‫‫\subsection*{تحلیل نتایج}
‫
‫در جداول زیر نتایج تمامی بنچ مارک ها نمایش داده شده است.
‫
‫\begin{figure}[H]
‫    \centering
‫    \includegraphics[width=\textwidth]{figs/b1.png}
‫    \caption{نتیجه بنچ مارک اول}
‫\end{figure}
‫\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{figs/b2.png}
    \caption{نتیجه بنچ مارک دوم}
\end{figure}
\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{figs/b3.png}
    \caption{نتیجه بنچ مارک سوم}
\end{figure}
\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{figs/b4.png}
    \caption{نتیجه بنچ مارک چهارم}
\end{figure}
\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{figs/b5.png}
    \caption{نتیجه بنچ مارک پنجم}
\end{figure}
\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{figs/b6.png}
    \caption{نتیجه بنچ مارک ششم}
\end{figure}

‫‫\section{ابزار RocksDB}
‫\subsection*{توضیحات}
‫RocksDB یک پایگاه داده کلید-مقدار یا Key-Value  بسیار سریع است که توسط Facebook توسعه داده شده است. این پایگاه داده به طور خاص برای ذخیره‌سازی و پردازش داده‌های حجم بالا در سیستم‌های دیسک‌محور بهینه‌سازی شده است. RocksDB بر اساس ساختار Tree Merge Log-Structured یا LSM Tree ساخته شده است که اجازه می‌دهد عملیات خواندن و نوشتن به طور مؤثر و با کارایی بالا انجام شوند.
‫
‫ویژگی‌ها و مزایا اصلی RocksDB:
‫
‫    • عملکرد بالا: RocksDB با استفاده از تکنیک‌های بهینه‌سازی حافظه و دیسک، عملکرد بسیار بالایی را برای حجم‌های عظیم داده‌ها ارائه می‌دهد.
‫
‫    • پشتیبانی از فشرده‌سازی: این پایگاه داده از انواع مختلف فشرده‌سازی برای ذخیره داده‌ها پشتیبانی می‌کند که باعث کاهش استفاده از فضای ذخیره‌سازی و افزایش سرعت عملیات می‌شود.
‫
‫
‫    • پشتیبانی از ویژگی‌های پیچیده: RocksDB می‌تواند برای پردازش داده‌های مقیاس‌پذیر، پشتیبانی از چندین لایه کش (Caching) و تراکنش‌های پیچیده، استفاده شود.
‫
‫    • پشتیبانی از پردازش موازی: این پایگاه داده می‌تواند برای خواندن و نوشتن داده‌ها در چندین نخ یا هسته پردازشی به طور همزمان پردازش کند و به همین دلیل برای سیستم‌های چند هسته‌ای بسیار مناسب است.
‫
‫
‫    • پشتیبانی از عملیات‌های خواندن و نوشتن تصادفی و ترتیبی: با توجه به طراحی LSM Tree، RocksDB می‌تواند به طور مؤثر هر دو نوع عملیات را پردازش کند.
‫
‫RocksDB برای برنامه‌های کاربردی‌ای که نیاز به پردازش داده‌های سریع و مقیاس‌پذیر دارند، مانند سیستم‌های ذخیره‌سازی بلادرنگ، تجزیه و تحلیل داده‌ها، و برنامه‌های مبتنی بر تحلیل داده‌های بزرگ یا Data Big بسیار مناسب است. این پایگاه داده معمولا در سیستم‌هایNoSQL ، برنامه‌های کشینگ، و سیستم‌های ذخیره‌سازی مقیاس‌پذیر استفاده می‌شود.
‫‫\subsection*{مراحل نصب}
‫ابتدا آن را کلون می‌کنیم:
‫
‫\begin{figure}[H]
‫    \centering
‫    \includegraphics[width=\textwidth]{figs/1.png}
‫    \caption{کلون RocksDB}
‫\end{figure}
‫
‫سپس به پوشه مربوطه رفته و make می‌کنیم و (برای مدت طولانی) منتظر می‌مانیم تا روند make تمام شود.
‫
‫\begin{figure}[H]
‫    \centering
‫    \includegraphics[width=\textwidth]{figs/2.png}
‫    \caption{make RocksDB}
‫\end{figure}
‫
‫\begin{figure}[H]
‫    \centering
‫    \includegraphics[width=\textwidth]{figs/3.png}
‫    \caption{اتمام make RocksDB}
‫\end{figure}
‫
‫پس از اتمام make، دستور مورد نظر برای اجرای تست ها را اجرا می کنیم.


‫با این دستور، اطلاعاتی مانند عملیات در ثانیه (IOPS)، تاخیرها (Latencies) و پهنای باند (Bandwidth) را دریافت می‌کنیم.
‫
‫متوجه شدیم که برای اجرای ابزارهای RocksDB به بسته gflags نیاز داریم. لذا ابتدا باید آن را نصب کنیم:
‫
‫\begin{figure}[H]
‫    \centering
‫    \includegraphics[width=\textwidth]{figs/4.png}
‫    \caption{نصب بسته gflags}
‫\end{figure}
‫
‫پس از اتمام نصب، نیاز است دوباره روند make را انجام دهیم. لذا وارد پوشه rocksdb می‌شویم و با \texttt{make clean} و پس از آن \texttt{make}، این کار را انجام می‌دهیم.
‫
‫پس از اجرای دوباره دستور مذکور، متوجه می‌شویم که برای استفاده از فشرده‌سازی با Snappy که نوعی الگوریتم فشرده‌سازی است، اتصال صحیح به RocksDB ایجاد نشده است. لذا باید بسته Snappy نصب شود:
‫
‫\begin{figure}[H]
‫    \centering
‫    \includegraphics[width=\textwidth]{figs/5.png}
‫    \caption{نصب بسته Snappy}
‫\end{figure}
‫
‫نهایتاً پس از نصب بسته Snappy، دستور db\_bench را اجرا می‌کنیم و خروجی را مشاهده می‌کنیم
‫
‫تفاوت این دستور با قبلی این است که آدرس مربوطه را در این دستور به طور کامل نوشته‌ایم و از \texttt{\textasciitilde} استفاده نشده است.
‫
‫‫\subsection*{بررسی کارکرد}
‫حال که RocksDB را به طور کامل نصب کرده ایم بنچ مارک db\_bench را به ترتیب مانند عکس های زیر تست می کنیم.
‫\begin{figure}[H]
‫    \centering
‫    \includegraphics[width=\textwidth]{figs/6.png}
‫    \caption{اجرای دستور db\_bench برای حالت ترتیبی}
‫\end{figure}
‫
‫\begin{figure}[H]
‫    \centering
‫    \includegraphics[width=\textwidth]{figs/7.png}
‫    \caption{اجرای دستور db\_bench برای حالت ترتیبی}
‫\end{figure}
‫
‫پس از آن نیز دستور درون تصویر را اجرا می‌کنیم تا عملکرد با داده‌های تصادفی را نیز بررسی کنیم:
‫
‫\begin{figure}[H]
‫    \centering
‫    \includegraphics[width=\textwidth]{figs/8.png}
‫    \caption{اجرای دستور db\_bench برای حالت تصادفی}
‫\end{figure}
‫
‫\begin{figure}[H]
‫    \centering
‫    \includegraphics[width=\textwidth]{figs/9.png}
‫    \caption{اجرای دستور db\_bench برای حالت تصادفی}
‫\end{figure}
‫
‫بدین شکل خروجی‌های مدنظرمان را دریافت می‌کنیم.
‫
‫‫\subsection*{تحلیل نتایج}
‫نمودار مقایسه بر اساس سرعت بین ۴ حالت مختلفمان بین نوشتن و خواندن‌های ترتیبی و تصادفی به شکل زیر می‌باشد:
‫
‫\begin{figure}[H]
‫    \centering
‫    \includegraphics[width=\textwidth]{figs/10.png}
‫    \caption{نمودار مقادیر خروجی برای هر کدام از عملیات}
‫\end{figure}
‫
‫در ادامه به تحلیل این آمار این نمودار و خروجی‌هایمان می‌پردازیم:
‫
‫\subsubsection*{عملکرد نوشتن (\lr{fillseq, fillrandom})}
‫
‫\textbf{نوشتن به صورت ترتیبی (\lr{fillseq})}
‫\begin{itemize}
‫    \item زمان عملیات: ۳.۳۸۷ میکروثانیه
‫    \item تعداد عملیات در ثانیه: ۲۹۵۲۲۲
‫    \item سرعت نوشتن: \lr{32.7 MB/s}
‫\end{itemize}
‫در هنگام نوشتن داده‌ها به صورت ترتیبی، \lr{RocksDB} عملکرد بسیار خوبی دارد. این نوع نوشتن داده‌ها معمولا به دلیل اینکه داده‌ها به صورت پیوسته در دیسک نوشته می‌شوند، نسبت به نوشتن تصادفی بسیار سریع‌تر است.
‫
‫\textbf{نوشتن به صورت تصادفی (\lr{fillrandom})}
‫\begin{itemize}
‫    \item زمان عملیات: ۵.۵۰۹ میکروثانیه
‫    \item تعداد عملیات در ثانیه: ۱۸۱۵۰۴
‫    \item سرعت نوشتن: \lr{20.1 MB/s}
‫\end{itemize}
‫در مقایسه با نوشتن ترتیبی، نوشتن تصادفی زمان بیشتری می‌برد. این تأخیر بیشتر ناشی از تغییر مکان‌های ذخیره داده‌ها در دیسک است. در این روش، \lr{RocksDB} باید جستجوهای بیشتری انجام دهد تا داده‌ها را در مکان‌های مختلف ذخیره کند که باعث افزایش زمان نوشتن می‌شود.
‫
‫\subsubsection*{عملکرد خواندن (\lr{readseq, readrandom})}
‫
‫\textbf{خواندن به صورت ترتیبی (\lr{readseq})}
‫\begin{itemize}
‫    \item زمان عملیات: ۰.۳۴۲ میکروثانیه
‫    \item تعداد عملیات در ثانیه: ۲۹۲۵۲۵۹
‫    \item سرعت خواندن: \lr{323.6 MB/s}
‫\end{itemize}
‫همانطور که انتظار می‌رود، خواندن داده‌ها به صورت ترتیبی سریع‌ترین عملکرد را دارد. علت این امر این است که خواندن داده‌ها به صورت ترتیبی به طور معمول به کش و سیستم‌های ذخیره‌سازی پیوسته کمک می‌کند؛ زیرا داده‌ها به طور فشرده و بدون وقفه از دیسک خوانده می‌شوند.
‫
‫\textbf{خواندن به صورت تصادفی (\lr{readrandom})}
‫\begin{itemize}
‫    \item زمان عملیات: ۹.۷۱۷ میکروثانیه
‫    \item تعداد عملیات در ثانیه: ۱۰۲۹۰۴
‫    \item سرعت خواندن: \lr{7.2 MB/s}
‫\end{itemize}
‫خواندن تصادفی معمولا زمان بیشتری می‌برد؛ زیرا سیستم باید به طور تصادفی به مکان‌های مختلف دیسک دسترسی پیدا کند. این امر باعث می‌شود که سرعت خواندن از نظر عملکرد بسیار کندتر از خواندن ترتیبی باشد. همچنین، به دلیل اینکه داده‌ها به صورت پراکنده ذخیره شده‌اند، عملکرد به طور مستقیم به وضعیت حافظه کش و مکان‌های ذخیره‌سازی بستگی دارد.
‫
‫\subsubsection*{مقایسه سرعت‌های خواندن و نوشتن در دو حالات جداگانه}
‫\begin{itemize}
‫    \item سرعت نوشتن ترتیبی (\lr{fillseq}): \lr{32.7 MB/s}
‫    \item سرعت خواندن ترتیبی (\lr{readseq}): \lr{323.6 MB/s}
‫\end{itemize}
‫سرعت خواندن بسیار بیشتر از سرعت نوشتن است، که این رفتار در بسیاری از سیستم‌های ذخیره‌سازی معمولی مشاهده می‌شود. این به این دلیل است که عملیات خواندن به صورت ترتیبی اغلب به حافظه کش یا سیستم ذخیره‌سازی سریع‌تر (مانند \lr{SSD}) انجام می‌شود و به این ترتیب سرعت خواندن بسیار بالاتر از نوشتن است.
‫
‫\begin{itemize}
‫    \item سرعت نوشتن تصادفی (\lr{fillrandom}): \lr{20.1 MB/s}
‫    \item سرعت خواندن تصادفی (\lr{readrandom}): \lr{7.2 MB/s}
‫\end{itemize}
‫در حالت تصادفی، نوشتن و خواندن هر دو کندتر هستند. برای نوشتن تصادفی، سیستم نیاز به پردازش بیشتری برای ذخیره داده‌ها در مکان‌های مختلف دارد، و برای خواندن تصادفی، همانطور که اشاره شد، سیستم باید به طور تصادفی به مکان‌های مختلف داده‌ها دسترسی پیدا کند که سرعت را کاهش می‌دهد.
‫
‫\subsubsection*{تأثیر فشرده‌سازی}
‫فشرده‌سازی در آزمایش‌ها از نوع \lr{Snappy} است که معمولا به عنوان یک الگوریتم فشرده‌سازی سریع شناخته می‌شود. معمولا تأثیر فشرده‌سازی در سرعت خواندن و نوشتن به صورت ترتیبی بیشتر از حالت تصادفی است.
‫\begin{itemize}
‫    \item \textbf{تأثیر بر نوشتن:} فشرده‌سازی می‌تواند حجم داده‌های ذخیره شده را کاهش دهد و سرعت نوشتن را در حالت‌های خاص افزایش دهد. به ویژه برای نوشتن داده‌های بزرگ، می‌تواند عملکرد بهتری را فراهم کند.
‫    \item \textbf{تأثیر بر خواندن:} هنگام خواندن داده‌ها، فشرده‌سازی ممکن است کمی زمان‌بر باشد؛ زیرا داده‌ها باید از حالت فشرده‌شده خارج شوند؛ اما این تأثیر معمولا در مقایسه با حجم داده‌های ذخیره‌شده قابل چشم‌پوشی است.
‫\end{itemize}
‫\section{مقایسه و نتیجه گیری}
‫
‫داده خام مربوط به خروجی ابزار آزمون
‫
‫تحلیل و مقایسه نتایج همراه با نمودار
‫
‫\برچسب{جدول:تقریب‌پذیری}
‫\پایان{لوح}
‫
‫